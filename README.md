# System programming in CSharp in Unity (Системное программирование на С# в Unity)
 Homework for Geekbrains

Урок 1. Асинхронное программирование в Unity. Coroutines. Async / Await

Задание 1. Применить корутины.

Дано:
1. Класс Unit, у которого есть переменная health, отвечающая за текущее количество жизней.
2. Метод RecieveHealing().
Задача: реализовать корутину, которая будет вызываться из метода RecieveHealing, чтобы юнит получал исцеление 5 жизней каждые полсекунды в течение 3 секунд или до тех пор, пока количество жизней не станет равным 100. На юнит не может действовать более одного эффекта исцеления одновременно.

Задание 2. Применить async/await.
Реализовать две задачи: Task1 и Task2. В качестве параметров задачи должны принимать CancellationToken. Первая задача должна ожидать одну секунду, а после выводить в консоль сообщение о своём завершении. Вторая задача должна ожидать 60 кадров, а после — выводить сообщение в консоль.

Задание 3 (дополнительное).
Реализовать задачу WhatTaskFasterAsync, которая будет принимать в качестве параметров CancellationToken, а также две задачи в виде переменных типа Task. Задача должна ожидать выполнения хотя бы одной из задач, останавливать другую и возвращать результат. Если первая задача выполнена первой, вернуть true, если вторая — false. Если сработал CancellationToken, также вернуть false. Проверить работоспособность с помощью задач из Задания 2.


Урок 2. Многопоточное программирование. Jobs System.

Часть 1: Создайте задачу типа IJob, которая принимает данные в формате NativeArray<int> и в результате выполнения все значения более десяти делает равными нулю.
Вызовите выполнение этой задачи из внешнего метода и выведите в консоль результат.

Часть 2. Cоздайте задачу типа IJobParallelFor, которая будет принимать данные в виде двух контейнеров: Positions и Velocities — типа NativeArray<Vector3>. Также создайте массив FinalPositions типа NativeArray<Vector3>.
Сделайте так, чтобы в результате выполнения задачи в элементы массива FinalPositions были записаны суммы соответствующих элементов массивов Positions и Velocities.
Вызовите выполнение созданной задачи из внешнего метода и выведите в консоль результат.


Урок 3. Сетевое программирование в Unity (Network Transport Layer). Часть 1

Задание 1. Добавьте поле ввода, куда игрок сможет ввести своё имя. Сделайте так, чтобы сразу после подключения к серверу клиент отправлял имя на сервер.

Задание 2. Создайте на сервере таблицу соответствия идентификаторов клиентов и их имён. Первое сообщение от клиента пусть записывается в качестве его имени. Внесите изменения, чтобы последующие сообщения пересылались с именем игрока, а не его номером.


Урок 4. Сетевое программирование в Unity (Network Transport Layer). Часть 2

Задание 1. В реализованном в текущем уроке проекте дополнить существующий код класса PlayerCharacter таким образов, чтобы в клиентах синхронизировалось не только положение аватаров в сцене, но и их вращение.

Задание 2. Добавить несколько точек спауна игроков на карте и реализовать появление нового подключенного игрока в рандомной точке.

Задание 3 (дополнительное). Реализовать возможность перестрелки между игроками. Расчёт попадания производить на сервере, используя луч из камеры игрока в направлении взгляда. При попадании передавать поражённому повреждения, уменьшая уровень его здоровья. При уменьшении здоровья до нуля отключить клиента от сервера с возможностью повторного подключения.


Урок 5. Сетевое программирование в Unity (Unity Network Transport Layer). Часть 3

Задание 1. Реализовать возможность задать каждому игроку имя. До подключения игрока к серверу. Пользователь имеет возможность установить для своего игрока уникальное имя, которое после подключения присваивается объекту игрока и становится видимым для других участников в виде метки над кораблём.

Задание 2. Реализовать столкновения с планетами и кораблями других игроков. При столкновении объект игрока должен быть уничтожен или отключен, после чего игрок перемещен в точку возрождения и объект корабля подменен на новый или включен.
